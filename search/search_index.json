{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SQLiteStudio Survival Guide","text":"<p>Field-tested. Independently verified.</p> <p>This is not the official manual. This is a practical guide for developers, testers, and survivors who want to understand what SQLiteStudio actually does.</p> <ul> <li>Start reading the guide</li> <li>Explore tools and tests</li> <li>Understand what's hidden</li> </ul> <p>Maintained by @cyberman</p>"},{"location":"archive/manual-2.1/","title":"PDF Manual: SQLiteStudio User Guide","text":"<p>This is a PDF file. Click the link below to download and open it in your preferred viewer.</p> <p>\u2b07 Download PDF manual</p>"},{"location":"archive/notes_on_manual/","title":"Notes on Original SQLiteStudio Manual (v2.1.0)","text":"<ul> <li>\ud83d\udcc5 Released: Between 2007\u20132012</li> <li>\ud83e\udde0 Covers SQLiteStudio Version: 2.1.0</li> <li>\ud83d\udcd8 Author: Pawe\u0142 Salawa</li> <li>\ud83c\udf10 Original Source: http://sqlitestudio.one.pl (now defunct)</li> </ul>"},{"location":"archive/notes_on_manual/#key-observations","title":"Key Observations","text":"<ul> <li>This manual reflects an older UI and behavior pattern.</li> <li>Many functionalities (like structure editing, rebuild automation, and FK handling) have since evolved.</li> <li>Version 3.x (which this repo is based on) changed the internal logic and plugin management system.</li> </ul>"},{"location":"archive/notes_on_manual/#why-archive-this","title":"Why archive this?","text":"<ul> <li>Historical reference</li> <li>Plugin system roots</li> <li>Contrast for documentation evolution</li> </ul>"},{"location":"context/00_official_refs/","title":"Official SQLiteStudio Documentation","text":"<p>Yes \u2013 there is an official user manual.</p> <p>\ud83d\uddd3\ufe0f Updated: Autumn 2024 \ud83d\udccd Location: GitHub Wiki \u2013 SQLiteStudio User Manual</p>"},{"location":"context/00_official_refs/#why-this-project-still-exists","title":"Why this project still exists","text":"<p>This repo is not a replacement, but an independent complement.</p> <p>We document:</p> <ul> <li>Unspoken behaviors of SQLiteStudio</li> <li>Real-world testing, table rebuild side effects</li> <li>Structural loss during commits</li> <li>Things the Wiki glosses over \u2013 or simply doesn't mention</li> </ul> <p>The SQLiteStudio Survival Guide Field-tested. Independently verified.</p> <p>When in doubt, consult both: - The official manual for features &amp; intent - This guide for truth &amp; implementation details</p> <p>Boingo-approved.  </p>"},{"location":"examples/","title":"Examples \u2013 SQLiteStudio Behavior Triggers","text":"<p>This folder contains minimal <code>.sql</code> snippets that demonstrate:</p> <ul> <li>When table rebuilds happen silently</li> <li>Which operations affect structure</li> <li>Safe and unsafe actions within SQLiteStudio</li> </ul>"},{"location":"examples/#included","title":"Included","text":"<ul> <li> <p><code>rebuild_not_null_example.sql</code>   \u2192 Shows how adding NOT NULL via GUI triggers a full rebuild</p> </li> <li> <p><code>foreign_key_rebuild_example.sql</code>   \u2192 Shows how adding a foreign key triggers a rebuild</p> </li> <li> <p><code>index_loss_example.sql</code>   \u2192 Demonstrates how editing column names may silently drop indexes</p> </li> </ul>"},{"location":"examples/foreign_key_rebuild_example/","title":"Foreign Key Addition Example","text":"<p>How to add a foreign key constraint to an existing table via rebuild.</p>"},{"location":"examples/foreign_key_rebuild_example/#example-sql","title":"Example SQL","text":"<pre><code>-- Example: Foreign Key Addition Triggers Rebuild\n\n-- Initial tables\nCREATE TABLE authors (\n    id INTEGER PRIMARY KEY,\n    name TEXT\n);\n\nCREATE TABLE books (\n    id INTEGER PRIMARY KEY,\n    title TEXT,\n    author_id INTEGER\n);\n\n-- Insert sample data\nINSERT INTO authors (id, name) VALUES (1, 'Asimov'), (2, 'Murakami');\nINSERT INTO books (id, title, author_id) VALUES (1, 'Foundation', 1), (2, 'Kafka on the Shore', 2);\n\n-- Now, if you add a FOREIGN KEY to books.author_id referencing authors.id via GUI,\n-- SQLiteStudio performs a rebuild behind the scenes.\n\n-- No ALTER TABLE ... ADD FOREIGN KEY is possible directly in SQLite.\n</code></pre> <p>\u2b07 Download raw SQL file</p>"},{"location":"examples/index_loss_example/","title":"Index Loss Example","text":"<p>This example demonstrates how index loss can occur during table rebuilds.</p>"},{"location":"examples/index_loss_example/#example-sql","title":"Example SQL","text":"<pre><code>-- Example: Index Loss on Structural Edit\n\n-- Create table with index\nCREATE TABLE cities (\n    id INTEGER PRIMARY KEY,\n    name TEXT\n);\nCREATE INDEX idx_city_name ON cities(name);\n\n-- Add some data\nINSERT INTO cities VALUES (1, 'Paris'), (2, 'Seoul');\n\n-- Now, edit the column name in SQLiteStudio (e.g., rename 'name' to 'city_name')\n-- This will trigger a rebuild and silently DROP your index unless manually restored.\n</code></pre> <p>\u2b07 Download raw SQL file</p>"},{"location":"examples/rebuild_not_null_example/","title":"NOT NULL Constraint Rebuild Example","text":"<p>Demonstrates how to rebuild a table to add a NOT NULL constraint.</p>"},{"location":"examples/rebuild_not_null_example/#example-sql","title":"Example SQL","text":"<pre><code>-- Example: Table Rebuild Trigger via NOT NULL constraint\n\n-- Initial table creation\nCREATE TABLE cities (\n    id INTEGER PRIMARY KEY,\n    name TEXT\n);\n\n-- Insert sample data\nINSERT INTO cities (id, name) VALUES (1, 'Berlin'), (2, 'Tokyo');\n\n-- Now, using SQLiteStudio to make 'name' NOT NULL\n-- will trigger a silent table rebuild under the hood\n\n-- Expected result:\n-- - a new table is created with NOT NULL enforced\n-- - data is copied (if valid)\n-- - old table is deleted and replaced\n</code></pre> <p>\u2b07 Download raw SQL file</p>"},{"location":"guide/01_overview/","title":"Overview: What SQLiteStudio Really Does","text":"<p>SQLiteStudio is a powerful but deceptive GUI for managing SQLite databases.</p> <p>This document is about what really happens under the hood \u2013 not what the interface suggests.</p>"},{"location":"guide/01_overview/#key-facts","title":"Key facts:","text":"<ul> <li>Almost every structural change triggers a full table rebuild.</li> <li>Commits are not simple \"Save\" operations \u2013 they may destroy and recreate tables.</li> <li>Foreign Keys appear to be editable later \u2013 but they actually require silent rebuilds.</li> <li>Indexes and constraints might get lost or regenerated without notice.</li> </ul>"},{"location":"guide/02_commits/","title":"Commit Behavior","text":""},{"location":"guide/02_commits/#myth","title":"Myth:","text":"<p>A \"commit\" in SQLiteStudio just saves your changes.</p>"},{"location":"guide/02_commits/#reality","title":"Reality:","text":"<p>A commit often means: - SQLiteStudio generates a new CREATE TABLE statement - It copies the data over - Deletes the old table - Renames the new table to the old name</p> <p>SQLiteStudio does not ask before doing this. It does it silently.</p>"},{"location":"guide/03_table_rebuilds/","title":"Table Rebuilds","text":"<p>When you: - Add NOT NULL - Add UNIQUE - Edit a data type - Change a column name - Add a FOREIGN KEY</p> <p>SQLiteStudio performs a hidden rebuild: - New table is generated - Data is copied - Old table is dropped - New table is renamed</p>"},{"location":"guide/04_foreign_keys/","title":"Foreign Keys in SQLiteStudio","text":""},{"location":"guide/04_foreign_keys/#can-you-add-a-foreign-key-later","title":"Can you add a Foreign Key later?","text":"<p>Yes, but only via rebuild.</p> <p>SQLite itself does NOT allow:</p> <pre><code>ALTER TABLE ADD FOREIGN KEY ...\n</code></pre> <p>SQLiteStudio fakes this by: - Creating a new table - Copying data - Dropping the old one</p> <p>You never see the process \u2013 but the result is a replaced table.</p>"},{"location":"guide/05_index_and_constraints/","title":"Indexes and Constraints","text":"<p>SQLiteStudio can set: - NOT NULL - UNIQUE - PRIMARY KEY - INDEX</p> <p>But beware: - Setting them after table creation often causes silent rebuilds. - If you're not watching, indexes can be lost during structural changes.</p>"},{"location":"tests/","title":"SQLiteStudio Behavior Test Cases","text":"<p>This folder contains <code>.sql</code> test scripts and documented test flows to verify SQLiteStudio behavior.</p> <p>These are intended to simulate: - Table rebuild scenarios - Index loss - Foreign key constraint handling - GUI-triggered structural side effects</p>"},{"location":"tests/#test-cases","title":"Test Cases","text":"<ul> <li> <p><code>test_index_survival_on_rename.sql</code>   \u2192 Rename a column and see if the index survives</p> </li> <li> <p><code>test_fk_addition_rebuild.sql</code>   \u2192 Add a FK and verify full table rebuild</p> </li> </ul>"},{"location":"tests/#how-to-use","title":"How to Use","text":"<ol> <li>Execute the SQL scripts step-by-step inside SQLiteStudio</li> <li>Perform the described GUI action</li> <li> <p>Observe side effects using <code>docs/tools/</code> helpers</p> </li> <li> <p><code>test_not_null_commit_effect.sql</code>   \u2192 Observe behavior when enforcing NOT NULL on nullable data</p> </li> <li> <p><code>test_table_copy_rollback_case.sql</code>   \u2192 Simulate canceling a structure change and verify rollback integrity</p> </li> </ol>"},{"location":"tests/test_fk_addition_rebuild/","title":"Foreign Key Addition Rebuild Test","text":"<p>Test for adding a foreign key by rebuilding the table.</p>"},{"location":"tests/test_fk_addition_rebuild/#test-sql","title":"Test SQL","text":"<pre><code>-- TEST: Rebuild Trigger on Foreign Key Addition\n\n-- Step 1: Create author/book tables\nCREATE TABLE test_authors (\n    id INTEGER PRIMARY KEY,\n    name TEXT\n);\n\nCREATE TABLE test_books (\n    id INTEGER PRIMARY KEY,\n    title TEXT,\n    author_id INTEGER\n);\n\n-- Step 2: Add FK in SQLiteStudio GUI: author_id \u2192 authors.id\n\n-- EXPECTED RESULT:\n-- Full rebuild of 'test_books' table\n\n-- VERIFICATION:\n-- Observe DB file timestamp or rowid mismatch\n</code></pre> <p>\u2b07 Download raw SQL file</p>"},{"location":"tests/test_index_survival_on_rename/","title":"Index Survival on Rename Test","text":"<p>Tests if indexes survive after table renaming operations.</p>"},{"location":"tests/test_index_survival_on_rename/#test-sql","title":"Test SQL","text":"<pre><code>-- TEST: Index Preservation on Column Rename\n\n-- Step 1: Create table and index\nCREATE TABLE test_city (\n    id INTEGER PRIMARY KEY,\n    name TEXT\n);\nCREATE INDEX idx_city_name ON test_city(name);\n\n-- Step 2: Rename column via SQLiteStudio GUI: 'name' \u2192 'city_name'\n\n-- EXPECTED RESULT:\n-- idx_city_name should be dropped unless manually recreated.\n\n-- VERIFICATION:\n-- Run:\n-- SELECT name FROM sqlite_master WHERE type='index' AND tbl_name='test_city';\n</code></pre> <p>\u2b07 Download raw SQL file</p>"},{"location":"tests/test_not_null_commit_effect/","title":"NOT NULL Commit Effect Test","text":"<p>Tests the effect of committing NOT NULL constraints.</p>"},{"location":"tests/test_not_null_commit_effect/#test-sql","title":"Test SQL","text":"<pre><code>-- TEST: Table Rebuild on Adding NOT NULL Constraint\n\n-- Step 1: Create a simple table without NOT NULL\nCREATE TABLE test_users (\n    id INTEGER PRIMARY KEY,\n    email TEXT\n);\n\n-- Step 2: Add some data\nINSERT INTO test_users (id, email) VALUES (1, 'a@example.com'), (2, NULL);\n\n-- Step 3: Attempt to set 'email' column as NOT NULL via GUI\n\n-- EXPECTED RESULT:\n-- Rebuild is triggered\n-- GUI should warn about existing NULL values\n-- Depending on GUI version, change might be blocked or data lost\n\n-- VERIFICATION:\n-- Run:\n-- SELECT * FROM test_users WHERE email IS NULL;\n</code></pre> <p>\u2b07 Download raw SQL file</p>"},{"location":"tests/test_table_copy_rollback_case/","title":"Table Copy Rollback Case Test","text":"<p>Test for rollback scenarios when copying tables.</p>"},{"location":"tests/test_table_copy_rollback_case/#test-sql","title":"Test SQL","text":"<pre><code>-- TEST: Cancelled Edit Should Preserve Original Table\n\n-- Step 1: Create a table\nCREATE TABLE test_notes (\n    id INTEGER PRIMARY KEY,\n    content TEXT\n);\n\n-- Step 2: Add data\nINSERT INTO test_notes VALUES (1, 'Draft'), (2, 'Final');\n\n-- Step 3: Begin structure edit in GUI (e.g., add new column), then CANCEL the dialog\n\n-- EXPECTED RESULT:\n-- No structure or data changes should persist\n-- If table has been silently rebuilt, a bug has occurred\n\n-- VERIFICATION:\n-- SELECT sql FROM sqlite_master WHERE name = 'test_notes';\n-- Should show no new columns\n</code></pre> <p>\u2b07 Download raw SQL file</p>"},{"location":"tests/results/fk_addition_rebuild.result/","title":"Test Result: Foreign Key Addition Rebuild","text":"<p>Test File: test_fk_addition_rebuild.sql Tester: cyberman Date: 2025-05-16 Environment: SQLiteStudio 3.4.4, Linux Mint 22.1</p>"},{"location":"tests/results/fk_addition_rebuild.result/#summary","title":"Summary","text":"<p>After manually adding a FOREIGN KEY to <code>author_id</code> referencing <code>authors.id</code> via GUI:</p> <ul> <li>GUI accepted the change</li> <li>File timestamp of database changed</li> <li>Rowid of table <code>books</code> regenerated</li> <li>Indexes preserved</li> <li>Table <code>books</code> was rebuilt</li> </ul>"},{"location":"tests/results/fk_addition_rebuild.result/#visual-evidence","title":"Visual Evidence","text":"<p>\ud83d\uddbc\ufe0f Screenshot before: fk_addition_before.png \ud83d\uddbc\ufe0f Screenshot after: fk_addition_after.png</p>"},{"location":"tests/results/fk_addition_rebuild.result/#additional-notes","title":"Additional Notes","text":"<pre><code>SELECT rowid, * FROM books;\n-- IDs differ from pre-rebuild if rowids were used originally\n</code></pre> <p>\u2705 Confirmed: Foreign key addition causes full rebuild in SQLiteStudio GUI</p>"},{"location":"tools/","title":"Tools for SQLiteStudio Verification","text":"<p>This directory contains small, focused tools to help validate or inspect SQLiteStudio behavior.</p>"},{"location":"tools/#tools","title":"Tools","text":"<ul> <li> <p><code>sqlite_commit_watch.sh</code>   \u2192 Bash script that watches when a SQLite file is modified (useful after GUI commits)</p> </li> <li> <p><code>index_checker.sql</code>   \u2192 Lists all user-created indexes, useful before/after table edits</p> </li> <li> <p><code>structure_diff.sql</code>   \u2192 Shows table structure (columns, types, constraints) \u2013 used for export comparisons</p> </li> </ul>"},{"location":"tools/#usage","title":"Usage","text":"<p>These tools are designed to be simple and platform-portable (where possible).</p> <ul> <li> <p><code>foreign_key_safety.sql</code>   \u2192 Detects *_id fields that aren't backed by actual FOREIGN KEY constraints</p> </li> <li> <p><code>index_repair.sql</code>   \u2192 Lists likely important fields that are missing indexes (e.g., *_id joins)</p> </li> </ul>"},{"location":"tools/foreign_key_safety/","title":"Foreign Key Safety Tool","text":"<p>Tool for checking foreign key safety in your database.</p>"},{"location":"tools/foreign_key_safety/#usage","title":"Usage","text":"<p>Paste the following SQL in SQLiteStudio and run:</p> <pre><code>-- foreign_key_safety.sql\n-- Detects tables with foreign key fields that are NOT enforced by an actual constraint\n\nWITH fk_columns AS (\n  SELECT m.name AS table_name, p.name AS column_name\n  FROM sqlite_master AS m\n  JOIN pragma_table_info(m.name) AS p\n  WHERE p.name LIKE '%_id' AND m.type = 'table'\n),\nfk_constraints AS (\n  SELECT DISTINCT m.name AS table_name, fk.\"from\" AS column_name\n  FROM sqlite_master AS m\n  JOIN pragma_foreign_key_list(m.name) AS fk\n)\nSELECT fk_columns.*\nFROM fk_columns\nLEFT JOIN fk_constraints\n  ON fk_columns.table_name = fk_constraints.table_name\n AND fk_columns.column_name = fk_constraints.column_name\nWHERE fk_constraints.column_name IS NULL\nORDER BY fk_columns.table_name, fk_columns.column_name;\n\n-- Purpose:\n-- Helps find \"foreign key looking\" columns (like 'author_id') that lack FK constraints.\n</code></pre> <p>\u2b07 Download raw SQL file</p>"},{"location":"tools/index_checker/","title":"Index Checker Tool","text":"<p>Analyze all indexes in your current SQLite database.</p>"},{"location":"tools/index_checker/#usage","title":"Usage","text":"<p>Paste the following SQL in SQLiteStudio and run:</p> <pre><code>-- index_checker.sql\n-- Lists all user-defined indexes in the current SQLite database\n\nSELECT\n  name AS index_name,\n  tbl_name AS table_name,\n  sql AS definition\nFROM\n  sqlite_master\nWHERE\n  type = 'index'\n  AND name NOT LIKE 'sqlite_%'\nORDER BY table_name, name;\n</code></pre> <p>\u2b07 Download raw SQL file</p>"},{"location":"tools/index_repair/","title":"Index Repair Tool","text":"<p>Script for repairing/rebuilding lost indexes.</p>"},{"location":"tools/index_repair/#usage","title":"Usage","text":"<p>Paste the following SQL in SQLiteStudio and run:</p> <pre><code>-- index_repair.sql\n-- Lists missing indexes for any FK or commonly used fields (e.g., *_id)\n\nSELECT\n  m.name AS table_name,\n  p.name AS column_name\nFROM\n  sqlite_master AS m\nJOIN\n  pragma_table_info(m.name) AS p\nWHERE\n  p.name LIKE '%_id'\n  AND NOT EXISTS (\n    SELECT 1\n    FROM sqlite_master AS idx\n    WHERE idx.type = 'index'\n      AND idx.tbl_name = m.name\n      AND idx.sql LIKE '%' || p.name || '%'\n  )\nORDER BY\n  m.name, p.name;\n\n-- Purpose:\n-- Helps suggest missing indexes on commonly joined fields (e.g., *_id columns).\n</code></pre> <p>\u2b07 Download raw SQL file</p>"},{"location":"tools/sqlite_commit_watch/","title":"SQLite Commit Watch Tool","text":"<p>A shell script to monitor commit behavior in SQLite databases.</p>"},{"location":"tools/sqlite_commit_watch/#usage","title":"Usage","text":"<p>Download the script and run it in your terminal:</p> <pre><code>#!/bin/bash\n# sqlite_commit_watch.sh\n# Watches the modification timestamp of a SQLite file\n\nDB=\"$1\"\n\nif [ -z \"$DB\" ]; then\n  echo \"Usage: $0 database.sqlite\"\n  exit 1\nfi\n\necho \"Watching file: $DB\"\nstat -c \"Last modified: %y\" \"$DB\"\n\necho \"Waiting for changes...\"\nwhile true; do\n  inotifywait -e modify \"$DB\" &gt;/dev/null 2&gt;&amp;1\n  echo \"Modified: $(date)\"\n  stat -c \"New timestamp: %y\" \"$DB\"\ndone\n</code></pre> <p>\u2b07 Download shell script</p>"},{"location":"tools/structure_diff/","title":"Structure Diff Tool","text":"<p>Find structural differences between two SQLite databases.</p>"},{"location":"tools/structure_diff/#usage","title":"Usage","text":"<p>Paste the following SQL in SQLiteStudio and run:</p> <pre><code>-- structure_diff.sql\n-- Lists all tables and their column definitions\n\nSELECT\n  m.name AS table_name,\n  p.cid,\n  p.name AS column_name,\n  p.type,\n  p.\"notnull\",\n  p.dflt_value,\n  p.pk\nFROM\n  sqlite_master AS m\nJOIN\n  pragma_table_info(m.name) AS p\nWHERE\n  m.type = 'table'\nORDER BY\n  table_name, p.cid;\n</code></pre> <p>\u2b07 Download raw SQL file</p>"},{"location":"troubleshooting/known_pitfalls/","title":"Troubleshooting","text":""},{"location":"troubleshooting/known_pitfalls/#i-added-a-fk-but-its-not-in-my-sql-export","title":"\"I added a FK but it's not in my SQL export!\"","text":"<p>\u2192 SQLiteStudio sometimes forgets to include FK definitions unless a full export is triggered.</p>"},{"location":"troubleshooting/known_pitfalls/#my-indexes-disappeared-after-editing-a-column","title":"\"My indexes disappeared after editing a column\"","text":"<p>\u2192 Table was silently rebuilt. Check the index list manually.</p>"},{"location":"troubleshooting/known_pitfalls/#how-do-i-know-if-a-commit-rewrote-my-table","title":"\"How do I know if a commit rewrote my table?\"","text":"<p>\u2192 Check file timestamp or size \u2013 a rebuild causes a rewrite.</p>"}]}